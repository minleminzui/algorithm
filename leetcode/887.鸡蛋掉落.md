```cpp
class Solution {
public:
    int superEggDrop(int k, int n) {
         // 这道题的核心在于 f(t,k) 实际上是表示“在最坏情况下（也就是不知道鸡蛋会在哪一层碎），在 t 次操作和 k 个鸡蛋的限制下，我们能确保检查的最大楼层数。选择一个楼层扔下一个鸡蛋。如果鸡蛋碎了，那么你失去了一个鸡蛋，但你知道 F 必须在这个楼层以下，所以你剩下 t-1 次操作去用 k-1 个鸡蛋去测试下方的楼层，即 f(t−1,k−1)。如果鸡蛋没碎，那么你没有失去鸡蛋，并且你知道 F 可以在这个楼层或者以上，所以你剩下 t-1 次操作去用 k 个鸡蛋去测试上方的楼层，即 f(t−1,k)。将这两个结果相加的原因是，我们实际上在每次操作之前都不知道鸡蛋是否会碎。因此，f(t,k) 实际上是表示“在最坏情况下（也就是不知道鸡蛋会在哪一层碎），在 t 次操作和 k 个鸡蛋的限制下，我们能确保检查的最大楼层数”。通过这样的动态规划，我们可以在不知道 F 的情况下，最大化我们的搜索范围。所以，这里的相加并不是说两个状态同时发生，而是在决策过程中考虑了所有可能的结果，并在此基础上进行了优化。我们的目标是找到一个最优策略，它能够确保在最坏的情况下（也就是不幸运的情况下鸡蛋总是在最后一次尝试时才不碎），最小化确定 F 的操作次数。
        // 所以说这里考虑的是最坏的情况，而不是考虑具体的某个情况。
        // 两种状态是互斥的，鸡蛋只可能由其中一种状态转移过来吧
        // ChatGPT
        // 对的，这两种状态是互斥的，也就是说在每一次扔鸡蛋的操作中，鸡蛋要么碎，要么不碎。但是这里的状态转移方程实际上用的是“计数”而不是“选择”。我们计算的是在给定的操作次数（t）和鸡蛋数（k）下，能检测的最多的楼层数，而不是具体的选择哪一层楼扔鸡蛋。
        // 这个状态转移方程的核心思想是，如果你有 t 次操作机会和 k 个鸡蛋，你可以采取以下策略来最大化你能检测的楼层范围：
        if (n == 1) {
            return 1;
        }

        // v[i][j]表示给定j次操作，i个鸡蛋
        vector<vector<int>> v(n + 1, vector<int>(k + 1));

        // O(kn)填充每个dp数据元素, O(kn)
        int ans = 0;
        for (int i = 1; i <= n ;++i) {
            for (int j = 1; j <= k; ++j) {
            //    分两种情况讨论：
            //    1. 蛋没碎了，对应v[i - 1][j]，也就是考虑这一层上面还有v[i - 1][j]
            //    2. 蛋碎了，对应v[i - 1][j - 1]，也就是考虑这一层下面还有v[i - 1][j - 1]
                v[i][j] = 1 + v[i - 1][j] + v[i - 1][j - 1];

            }
            if (v[i][k] >= n) {
                ans = i;
                break;
            }
        }
        return ans;
    }
};
```