  138. `链表`
       两种方法，第一种迭代+拆分，第二种哈希。
       `时间复杂度：`第一种是O(n),第二种是O(n)。
       `空间复杂度：`第一种是O(1),第二种是O(n)。

<details>
<summary>点击查看代码</summary>


```
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head) return head;
        for(Node *node = head; node; node = node -> next -> next){
            Node *t = new Node(node -> val);
            t -> next = node -> next;
            node -> next = t;
        }
        for(Node *node = head; node; node = node -> next -> next){
            node -> next -> random = (node -> random == nullptr) ? nullptr : node -> random -> next;
        }
        Node *ans = head -> next;
        for(Node *node = head; node; node = node -> next){
            Node *t = node -> next;
            node ->next = node -> next -> next;
            t -> next = (t -> next == nullptr) ? nullptr : t -> next -> next;
        }
        return ans;
        // if(!head) return head;
        // unordered_map<Node*, Node*> m;
        // Node* nHead = new Node(head -> val), *move = head -> next;
        // Node *dummy = nHead;
        // m[head] = nHead;
        // m[nullptr] = nullptr;
        // while(move){
        //     Node *t = new Node(move -> val);
        //     m[move] = t;
        //     nHead -> next = t;
        //     nHead = t;
        //     move = move -> next;
        // }

        // nHead = dummy, move = head;
        // while(dummy){
        //     dummy -> random = m[move -> random];
        //     dummy = dummy -> next;
        //     move = move ->next;
        // }
        // return nHead;


    }
};
```

</details>